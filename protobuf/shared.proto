syntax = "proto2";
package starbelly;

/// Login information for a domain.
message DomainLogin {
    optional string domain = 1;
    optional string login_url = 2;
    optional string login_test = 3;
    optional int32 auth_count = 4;
    repeated DomainLoginUser users = 5;
}

/// Username/password for a domain.
message DomainLoginUser {
    optional string username = 1;
    optional string password = 2;
    optional bool working = 3;
}

// Contains a crawl response, i.e. something downloaded by the crawler or the
// error/exception that resulted from attempting to download it.
message CrawlResponse {
    optional bytes body = 1;
    optional string completed_at = 2;
    optional string content_type = 3;
    optional double cost = 4;
    optional double duration = 5;
    optional string exception = 6;
    repeated Header headers = 7;
    optional bool is_body_compressed = 8;
    optional bool is_success = 9;
    optional bytes job_id = 10;
    optional string started_at = 11;
    optional int32 status_code = 12;
    optional string url = 13;
    optional string url_can = 14;
}

// An HTTP header.
message Header {
    optional string key = 1;
    optional string value = 2;
}

// The various run states a job may have.
enum JobRunState {
    CANCELLED = 1;
    COMPLETED = 2;
    PAUSED = 3;
    PENDING = 4;
    RUNNING = 5;
    DELETED = 6; // This isn't really a valid run state. It indicates that job
                 // no longer exists.
}

// A crawl job.
message Job {
    required bytes job_id = 1;
    repeated string seeds = 2;
    optional Policy policy = 3;
    optional string name = 4;
    optional TagList tag_list = 5;
    optional JobRunState run_state = 6;
    optional string started_at = 7;
    optional string completed_at = 8;
    optional int32 item_count = 9 [default = -1];
    optional int32 http_success_count = 10 [default = -1];
    optional int32 http_error_count = 11 [default = -1];
    optional int32 exception_count = 12 [default = -1];
    map<int32, int32> http_status_counts = 13;
}

// A list of jobs.
//
// This seemingly stupid message is necessary so that a list of jobs can be
// used as the body of a "oneof".
message JobList {
    repeated Job jobs = 1;
}

// Define time units that may be used for scheduling a job.
enum JobScheduleTimeUnit {
    MINUTES = 1;
    HOURS = 2;
    DAYS = 3;
    WEEKS = 4;
    MONTHS = 5;
    YEARS = 6;
}

// Define when a job should be scheduled.
//
// AFTER_PREVIOUS_JOB_FINISHED → Schedule a job X units of time after the
// previous job completes.
// REGULAR_INTERVAL → Schedule a job every X units of time; if the previous
// job is still running, end it.
enum JobScheduleTiming {
    AFTER_PREVIOUS_JOB_FINISHED = 1;
    REGULAR_INTERVAL = 2;
}

// Schedule information for a job.
message JobSchedule {
    required bytes schedule_id = 1;
    optional string created_at = 2;
    optional string updated_at = 3;
    optional bool enabled = 4;
    optional JobScheduleTimeUnit time_unit = 5;
    optional int32 num_units = 6;
    optional JobScheduleTiming timing = 7;
    optional string schedule_name = 8;
    optional string job_name = 9;
    repeated string seeds = 10;
    optional bytes policy_id = 11;
    optional TagList tag_list = 12;
    optional bytes latest_job_id = 13;
    optional int32 job_count = 14;
}

// A list of job schedules.
//
// This seemingly stupid message is necessary so that a list of job schedules
// can be used as the body of a "oneof".
message JobScheduleList {
    repeated JobSchedule job_schedules = 1;
}

// For paginating large sets.
message Page {
    optional int32 limit = 1 [default = 10];
    optional int32 offset = 2;
}

// Specifies how a regex pattern should be used.
enum PatternMatch {
    MATCHES = 1;
    DOES_NOT_MATCH = 2;
}

// Settings that dictate crawler behavior. Policy is set on a job-by-job basis.
message Policy {
    optional bytes policy_id = 1;
    optional string name = 2;
    optional string created_at = 3;
    optional string updated_at = 4;

    optional PolicyAuthentication authentication = 6;
    optional PolicyLimits limits = 7;
    repeated PolicyProxyRule proxy_rules = 8;
    repeated PolicyMimeTypeRule mime_type_rules = 9;
    optional PolicyRobotsTxt robots_txt = 10;
    optional PolicyUrlNormalization url_normalization = 13;
    repeated PolicyUrlRule url_rules = 11;
    repeated PolicyUserAgent user_agents = 12;
}

// Settings for authenticated crawling.
message PolicyAuthentication {
    optional bool enabled = 1;
}

// Specifies limits on how far or how long a crawl runs.
message PolicyLimits {
    optional double max_cost = 1;
    optional double max_duration = 2;
    optional int32 max_items = 3;
}

// Specifies whether to save or discard certain responses based on MIME type.
//
// If pattern is not specified, then this rule applies to all responses.
message PolicyMimeTypeRule {
    optional string pattern = 1;
    optional PatternMatch match = 2;
    optional bool save = 3;
}

// When and how to proxy requests.
message PolicyProxyRule {
    optional string pattern = 1;
    optional PatternMatch match = 2;
    optional string proxy_url = 3;
}

// Specify handling of robots.txt.
message PolicyRobotsTxt {
    enum Usage {
        OBEY = 1;   // Obey robots.txt rules.
        INVERT = 2; // Do the opposite of robots.txt rules.
        IGNORE = 3; // Ignore robots.txt.
    }

    required Usage usage = 1;
}

message PolicyUrlNormalization {
    optional bool enabled = 1;
    repeated string strip_parameters = 2;
}

// A rule for adjusting a URL's cost.
message PolicyUrlRule {
    enum Action {
        ADD = 1;      // Add `amount` to parent cost.
        MULTIPLY = 2; // Multiply parent cost by `amount`.
    }

    optional string pattern = 1;
    optional PatternMatch match = 2;
    optional Action action = 3;
    optional double amount = 4;
}

// Specifies a user agent string to send when downloading a resource.
message PolicyUserAgent {
    required string name = 1;
}

// Model for a rate limit.
//
// If domain is not specified, the global rate limit is modified. If delay
// is not specified, then the rate limit for the specified domain is deleted.
// Either delay or domain must be specified: you are not allowed to delete the
// global limit.
//
// Name is optional: if the client sends a name, the server ignores it. The
// server will always send a name to the client.
message RateLimit {
    optional string name = 1;
    optional float delay = 2;
    optional string domain = 3;
}

// A list of tags.
//
// This seemingly pointless message is actually useful because it allows us
// to differentiate between an empty list and a null list.
message TagList {
    repeated string tags = 1;
}
